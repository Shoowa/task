#! /bin/bash

# Simple naming scheme.
redis=cacher
app=hitcount

# Remove an older Redis CLI pod if it exists.
kubectl delete pods redis-client --force
helm uninstall $redis $app
echo 'waiting 10 seconds...'
sleep 10

# Prepare Helm.
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# First, install the Redis cache.
helm install $redis oci://registry-1.docker.io/bitnamicharts/redis

# Await Redis Master via loop.
cacheReady=false
while ! $cacheReady; do
    echo 'waiting...'
    sleep 3
    cacheReady=$(kubectl get pods $redis-redis-master-0 -o jsonpath='{.status.containerStatuses[*].ready}')
done

# Second, read the password generated by the Helm chart.
export REDIS_PASSWORD=$(kubectl -n default get secret $redis-redis -o jsonpath="{.data.redis-password}" | base64 -d)

# Third, create a Redis CLI pod.
kubectl -n default run redis-client --restart='Never'  --env REDIS_PASSWORD=$REDIS_PASSWORD  --image docker.io/bitnami/redis:7.0.11-debian-11-r20 --command -- sleep infinity

# Await Redis CLI pod.
cliReady=false
while ! $cliReady; do
    echo 'waiting...'
    sleep 3
    cliReady=$(kubectl get pods redis-client -o jsonpath='{.status.containerStatuses[*].ready}')
done

# Fourth, remote execution: Redis CLI writes new key to a Redis database selected by an E-Var.
kubectl -n default exec --tty -i redis-client -- bash -c "REDISCLI_AUTH="$REDIS_PASSWORD" redis-cli -h $redis-redis-master -p $REDIS_PORT -n $REDIS_DB set HIT_COUNT 0"

# Fifth, install the Flask app, and point it to the Redis SVC Object.
helm install --set redisUser=$REDIS_USERNAME --set redisPassword=$REDIS_PASSWORD --set redisHost=$redis-redis-master --set redisPort=$REDIS_PORT --set redisDb=$REDIS_DB $app ./chart

# Warn tester
echo 'Please wait 15 seconds for the Readiness Probe to fire. Absent a dedicated route that simply health-checks the Redis server through the Flask app, the current index will suffice.'
